# Advent of Code 2024

- https://adventofcode.com/
- https://github.com/livexia/advent-of-code-2024

## 移除所有的 input.txt

根据社区和作者的规定，其实参与者并不允许上传 input 到公共仓库，我之前一直没有意识到这个问题，所以为了可确定性所以一直上传输入，今天意识到这个问题，所以删除了所有的输入，也许还有少量残留（不太可能）。

使用的方法来自社区：
1. [Puzzle Inputs](https://old.reddit.com/r/adventofcode/wiki/faqs/copyright/inputs)
2. > git filter-repo --path-glob "2022/*/input" --invert-paths --force was the nice way to fix this for me. Edit the glob to match how you had inputs saved
    - 需要重新配置仓库远端地址，同时需要强制推送代码，以及 github 可能存在短暂的更新延时，以及可能的云端缓存，不是很确定，以及会丢失本地的 input 文件，也算是我的教训吧，下次记得要检查类似的问题。
    - [fragger](https://old.reddit.com/r/adventofcode/comments/18ehed6/re_not_sharing_inputs_psa_deleting_and_committing/kcroxma/)
3. [newren/git-filter-repo](https://github.com/newren/git-filter-repo)

## Day 1

太久没编程，还好大部分的记忆还在，有一点点手生，但是没什么问题。

## Day 2

第二天的题目并不困难，第一部分很简单，前后比较即可，第二部分虽然想有更好的方法，但是思路并不那么清晰，最后就暴力解决了，因为输入的问题，所以效率也不差。输入的数据每行的长度也不大，同时数据每行大都是有序的，而且也只考虑移除一个元素后数列的变化情况，所以实际上问题的求解空间就不大。如果输入数列趋于无序，同时需要计算删除最少元素以保证数列排序要求，那么求解空间就变得很大了，暴力实现也就不怎么现实了。在社区上简单浏览了一下也没有看见贴别好的方法，也许还要再等等吧，就这样了。

## Day 3

第三天的题目依旧不困难，但是在输入的处理上稍有麻烦，太久没编程都忘了还能用 regex 处理输入了，刚开始想要自己实现输入的匹配，但是没能下定决定，然后浪费了不少时间。虽然对 regex 并不是很熟练，但是基础还是有的，所以写个简单的表达式并没有问题，利用[网站](https://regex101.com/)简单的测试，再根据 [regex](https://docs.rs/regex/latest/regex/index.html) 的文档很容易的就实现了输入的解析和处理。对输入的计算其实很容易，再处理完输入之后很容易就可以得出结果。

## Day 4

今天的题目真的很简单，但是我却花了太多的时间，第一部分很快就有解决方法了，以为会出现的深度搜索也不需要，最后我的示例答案和正确答案差 1 ，我就知道有个边界错误了，但是光看是看不出来的，最后在纸上手动计算了一下，对比了差异，果然在边界上判断错误了。可能是小瞧了难度，所以写代码的时候有点过于花样多了，导致要从代码调试输出更加困难，而我又不想改，所以浪费了很多的时间。第一部分需要在水平、垂直和对角方向上搜索单词，注意无论是什么方向，单词都是在一行的，这极大的降低了问题难度。从一个位置出发，实际上需要匹配八个方向的所有可能，因为单词可以是翻转的，所以我并没有匹配八个方向，而是判断当前位置是和单词的第一个字符还是最后一个字符相同，如果和最后一个字符相同，那就翻转单词，这样在一个位置其实最多只需要寻找四个方向。第二个部分更加简单，只需要找到所有的字符 A 即可，判断以 A 为中心的，两个对角线的单词是否是 MAS 或 SAM 即可，只有都满足的情况才是正解，也就是说对于一个字符 A 其实只存在一个可能性。第一部分中无论是对于字符 X 还是 S ，其实都存在四种可能（我的解法）。吸取教训，不要求快，求快反而更慢了。

## Day 5

今天的题目依旧不难，但我还是太不熟练了，在很多的地方有的思路并不是最佳的，这些思路可能一年前对我来说是很自然的。题目给出的输入是一组排序规则，其中确定部分元素的前后关系，还有的一部分输入是可能有序的序列，第一部分要寻找其中已经按照排序规则有序的序列，取得中间元素的值。第二部分则要对未排序的序列进行排序，取得排序后序列中间元素的值。我的思路很直接明了，就是搜索，我先把输入的序列规则进行了处理，确定在一个元素之后的所有元素（对输入规则进行拓扑排序）。题目要求的是，需要排除序列中没有元素的排序规则，所以实际上对每一个序列都需要处理输入规则，也就是说对不同的序列，其实有不同的排序规则，因为如果不针对输入序列进行再次处理，会发现输入规则的拓扑排序存在环，那么所有的排序都是可行的，但其实存导致环的规则并不会同时出现在一个序列中，所以对于任一序列，规则是不存在环的（因为排除了）。按照我的方法，处理排序规则就已经有不少的复杂度了。然后在第二部分，需要对未排序的序列进行排序，我使用的排序算法也不是最好的，遍历比较前后元素，如果不符合排序规则就交换两个元素，然后回溯比较前一对是否有序（当前两个交换会影响前一对的比较结果）。

其实除了没有使用更好的排序算法，我的方法没啥问题，对需要的规则进行拓扑排序，但是在阅读社区的解法和讨论之后，我意识到对于序列中任何两个相邻的元素，必然存在规则确定二者的大小关系，即如果存在 `a|b` 和 `b|c` 两条规则，那么规则 `a|c` 必然存在，所以对于某一输入序列而言，实际上一定存在对应的规则，也就是说对于某一输入而言，其实完全不需要进行拓扑排序，即可能发生的比较都已经在需要的规则中确定好了，只需要取用即可。在对自己爹输入测试之后果然如此，理所当然的这个方法比我自己的方法要快很多。

参考：[\[2024 Day 5\]Rules are not a DAG ](https://www.reddit.com/r/adventofcode/comments/1h73c98/2024_day_5_rules_are_not_a_dag/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)

## Day 6

今天的题继续不难，提交的成绩比前几天好太多了，但是在完成之后依旧卡壳。这类型的题目已经是 AOC 的传统艺能了，所以在输入处理和抽象建立上并没有问题，第一部分就是按照提议要求模拟行走就行，很简单。第二部分很明显复杂了一些，但是本质上还是做 N 次第一部分的内容，所以实际上理解也不困难，并没有很直接的算法能够加快这个过程。很自然的，我尝试用暴力法，逐一替换给出地图中的路径为障碍，然后一一测试是否存在环路，环路判断只需要用 `HashSet` 保存守卫的位置和前进方向，然后当再次遇到状态一模一样的守卫时，就发现了环。理所当然的这个方法的效率并不好。因为每次守卫巡逻，最多只允许替换一次路径为障碍，那么实际上对那些守卫本就不会走到的路径就没有必要替换为障碍进行测试，所以可以先把不替换时守卫巡逻的所以位置进行记录，然后只需要对这些位置进行替换，再测试环即可，这可以大量降低运行时间。那么能不能再进一步加快运行效率呢？我就是卡在这个问题上了。在前面两种方法中，每次替换并检测环的时候，守卫都是从起始位置行走的，那存在大量的重叠运算，假如被替换的位置处于守卫巡逻路径的最后部分并且相邻，那么理论上可以对部分的运算进行复用。所以我就有了这样的思路，守卫在巡逻路径上某一个位置的时候，他存在两种选择，第一就是按照未替换的巡逻路径前进一个位置，或者把路径下一个位置替换为障碍，即守卫进行转向。对于巡逻路径上的每一个位置都存在两种选择，所以对于长度为 N 的巡逻路径未替换的路径需要计算一次，除去初始位置其余位置都需要计算一次。如果路径不存在交叉，也就是最理想的情况，那么总共需要移动的次数就是 N + (N - 1) + (N + 2) + ... + 1，这个结论不完全正确，因为当一个位置被替换后，其实路径的长度也会变化。刚开始我一直没有考虑可能的路径交叉情况，正是在这个情况的判断上，我无法取得正确的结果。

考虑位置 A 处于巡逻路径的某个位置，而且路径会多次经过 A ，如果在首次前进到 A 处，测试将 A 替换为路障是否存在环路。如果不存在那么按照原本的巡逻路径继续前进再次到达 A 位置时是否需再次测试？这个情况下是不需要测试的，因为如果进行替换，那么首先到达当前状态的前提就不存在了，替换并不是在前进到某个时刻随意选择替换的，而是在守卫开始走的时候就进行替换的。回到如果 A 存在回路的情况，那么按照原本路径再次到达 A 时同样的也不需要进行测试，因为替换 A 已经验证是存在回路的。

按照这个思路实现的代码结果依旧不对，相比于正解更少的位置在替换后能使得守卫巡逻路径为环路，也就是存在部分环路没有被成功的检测，也许是环路检测部分的代码有问题。考虑边界情况，起始和路径上的其他位置没差别，因为替换的是下一个位置的，路径最后一个位置时，下一个位置不在输入范围内，所以也就不存在两种情况。在写下这段思考之后，仔细研究发现在判断交叉位置的部分是存在错误的，调整之后这个方法毫无问题。

代码在 release 编译下从最初的 8s 到中间的 2s 到现在的 500ms ，代码效率提升明显，但是仍旧不快，因为大量使用了 `HashSet` ，在火焰图中也可以发现 Hash 的相关操作占据了大部分的运行时，这个部分依旧可以优化。需要哈希的主要数据类型是两个 `usize` 构成的 `tuple `和一个 `enum` ，理论上的哈希操作并不困难。观察火焰图可以发现存在大量的 `rehash` ，就是说存在大量哈希重新计算的情况，大概率是 `HashSet` 的容量增长导致的，所以在新建 `HashSet` 的时候可以提前分配一个较大的空间，这样操作之后运行时间减少一半，同样的 `rehash` 在火焰图中也没有多少。当然这样的性能提升依旧有限，因为还是存在大量的 `insert` 操作，也许可以换第三方的哈希库，但是也许可以用完全不同的方法。

在某一个位置，守卫最多存在四种前进方向，也就是说某一个位置最多存在四种状态，那么就可以用一个三维数组存储这些，直接利用数组替换哈希，测试发现数组比哈希更慢，这也可以理解，因为数组需要更大的空间，哈希其实还是只用了较少的空间。因为输入的大小为 130x130 理论上可以用大小为 `[[u64; 43]; 130]` 的 array 对应输入二维矩阵每个位置的状态，同样只需要四个这样的 array 对应守卫在每一个位置可能有的四种状态。通过位运算，可以将每个坐标对应到这个 array 中 u64 的一个 bit 上，这也是 AOC 中经常出现的优化。我在今天的题目上已经花了很多的时间，就随它去。

参考了 Reddit 的[评论](https://www.reddit.com/r/adventofcode/comments/1h7vpqi/comment/m0pcrrh/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) 和[帖子](https://www.reddit.com/r/adventofcode/comments/1h8g6za/2024_day_6_part_2_various_optimization_tricks/) 我意识到在环检测的时候，只需要保存在守卫发生转向时的状态即可，如果成环那么守卫一定会走过每个角落多次，这可以减少需要保存和检查的状态值。这个优化是显著的，在 debug 编译下，运行时间降低到了 300ms ，release 下则降低到了 70ms。

## Day 7

也许是最简单的一天，这让我担心明后天的题目了，没有什么特别的花样，老老实实的暴力递归解决，清晰明了，看社区貌似也没更好的方法。有一个 rust 的语法糖（？），可以用 `checked_ilog10` 确定一个数的十进制长度。

## Day 8

题目在描述上有些含糊不清，和前后矛盾，理论上一条直线上的三个点，分别为 A，B 和 C，其中 A 和 C 的距离刚好是 B 和 C 的距离的一半或者一倍，A 和 B 位置确定，那么满足这个条件的点 C 应该有四种可能，题目却说只有两种可能。对这两种可能题目很明确的说是在两点的两侧，也就是说不可能落在两点之间。从这个条件出发，计算 A 和 B 两个方向上的距离差，然后第一部分只要点 A 减去距离差以及点 B 加上距离差即可，第二部分则是不断进行这个延伸，直到超出边界。题目很简单，说实在的也没什么优化的空间。

## Day 9

一看见题目就知道应该采取怎么样的思路，但是太久没写类似的题目了，所以只有大概的思路，很明显是需要用区间解决的。但是我在决定该如何表达区间上犹豫不决花了太多的时间，所以我决定用暴力法试试看，在计算了需要的数组大小并不是特别大之后，用模拟的方法很容易的就解决了今天的问题，当然运行时间并不好，所以我还是需要用区间的思路解决。输入包含了两类区间，分别是文件和空闲，第一部分需要将文件拆分，填满空闲区间，文件从尾部开始拆分，而空闲空间从头部开始填满。第二部分则是不将文件拆分，需要将整个文件移动到可以容纳的空闲区间。

考虑第二部分，当一个文件移动到一个空闲空间时，首先文件占用的位置设为空，因为是从尾部的文件开始移动，而且一个文件最多只能尝试移动一次，所以位置上在这个文件之后的文件都已经被尝试过了，同时因为文件都是向前移动，所以这个文件移动后留空的部分只需要置空，而无需将其是做可能有文件会移动的空闲空间（空闲但不允许被写入）。然后考虑被占用的空闲空间，首先存在两种情况，一是大小刚刚好，那么这个空闲空间需要被删除，后续其他文件的移动无需考虑，而是大小大于文件的大小，那么就要调整空闲空间的区间值。

考虑第一部分，当一个文件移动后留下的空闲空间依旧是无法作为移动的空闲空间使用。当文件小于空闲空间时，实际上就是第二部分，而当文件大于空闲空间时，则需要拆分文件的区间，优先处理一部分文件，同样的处理过的文件不在移动。实际上对于第一部分，其实用暴力法来的更加方便，因为并不存在文件间的区分，而且从头部开始的空闲空间总是会被填满的，以及尾部的占用空间总是会移动，所以只需要用双指针分别表示最初的空闲空间以及最后的占用空间即可，然后不断的替换两个指针处的空间即可，时间复杂度是 O(N) ，虽然利用区间进行计算，时间复杂度应该也是 O(N) ，但是涉及到文件间的区分，逻辑上就更加复杂了。实际上的运行时也有差距，在第一部分就使用区间涉及到更多的查找操作，或者是移除无用的空闲空间所耗费的开销。

应该能进一步的优化，第二部分中查找符合大小的空闲区间我是直接线性搜索的，应该存在更好的搜索算法，也许可以维护一棵树？Reddit 社区有提到区间树，应该可以更快的找到满足要求的区间，只不过题目比一般的区间树其实存在更多的要求，比如移动后的空闲区间不能再使用（不插入区间树），以及区间要移动到起点较小的区间（需要修改区间树的查询？）。

参考：[Interval tree](https://en.wikipedia.org/wiki/Interval_tree)

## Day 10

今天的题目很简单，输入处理也很简单，输入也很小，搜索路径。两个部分之间也没什么差别，第一部分需要计算从一个位置能达到多少个目标，第二部分则需要计算从一个位置能有多少路径达到目标。第一部分误读了几次题意，其实就出现了第二部分的解。第一部分可以保存搜索过的路径，减少搜索空间，第二部分则可以保存搜索过的每个位置到目标的路径数，动态规划，减少搜索空间。但是因为输入太小了，所以根本无所谓，递归的深度优先搜素或者迭代的广度优先搜索都可以实现。

## Day 11

给定的输入其实很小，处理也相当容易，看完题目其实就知道是存在某种循环、规律，第一部分往往都可以直接模拟解决，经过一次变化，石头数最多翻倍，第一次的变化次数很少，所以在时间、空间复杂度上，简单的模拟是完全可以实现的。

第二部分循环的次数增加的，对于模拟而言次数增加一次，模拟操作是翻倍的，所以时间、空间复杂度是指数增长的，需要寻找某种模式或者更好的算法。对于类似的变化题目，很大程度上都是要寻找某种固定的模式，减少实际需要模拟的次数。简单的检查每次变化后石头的数字， 发现第二部分很明显会进入一个循环的状态，所有石头可能的数字并不增加，数字相同的石头不断增加。那么就可以对石头的转换进行缓存，保存每次缓存的结果，当再次遇到一样数字的石头时直接从缓存中取得即可，不需要重复的模拟。同时在计算过程中并不保存所有石头，而是记录每个石头出现的次数，那么就可以很轻易的计算（乘法）出所有这些相同数字的石头经过变换后会变为哪些石头。也许可以进一步分析每一次变化后，相同数字石头数量的变化，确定这个规律后，甚至可以直接取消重复模拟计算。当然这个规律并不容易取得，而且存在石头间的变化，所以单对一个数字进行分析是很难推出规律的，实际的测试也说明这一点。

再阅读了部分社区的解法之后，也有一个类似但不同的思路，类似动态规划，令 f(x, n) 为数字为 x 的石头经过 n 次变化后可能的石头数，那么根据变化规则就可以判断 f(x, n) 为 f(1, n - 1) 或者 f(left(x), n - 1) + f(right(x), n - 1) 或者 f(x * 2024, n) ，同时如果 n 为 0 f(x, 0) = 1，这就是石头变化数量的转换方程。转换过程中只需要缓存即可。某种程度上这两种角度是同一个方法的不同表现，第一种方法减少了每次需要判断的石头数，第二种方法则是减少了转换的次数。  

## Day 12

应该是连通性的问题，连接区域的面积比较容易计算，可以计算区域中和相邻区域接触的数量即可，用深度搜索实现即可，当前位置的四个方向上存在不是本区域的植物即是边界的一部分，第一部分还是很轻松的，只是要在搜索过程中排除已经搜索过的位置即可。

第二部分需要计算连接面积的边的数量，处在边上的元素最多只和两个相同元素相连，当存在转弯时，搜索到新的边。这个思路没问题，但是实际的实现并不清晰，浪费了很多时间，最后我决定用笨办法，遍历区域中所有的点，确定四个相邻的点有多少是在区域内的，如果四个都在区域内说明这个点不在边上。如果有三个都在区域内，说明这个点在边上，只有一个方向与其他区域相邻，然后我记录这个边的直线以及这个点是在这个边的哪个方向（边的哪个方向是不在区域内的），将边和边的方向作为哈希表的键，以及点作为哈希表的值进行保存。同样的如果只有两个相邻的点在区域内，那么这个点就存在两个边上，同样的写入哈希表。一样的保存只有一个相邻点在区域内时三边和对应方向到哈希表。

参考 Reedit 的解法之后，其实我的第一个思路是没问题的，只不过我没意识到只要确定区域每有一个角就有一个边。~而实际上在我的第二个方法里，我已经计算了角的数量，如果一个位置的四个相邻位置中有四个都在区域内，这个位置一定不是角，如果有三个都在区域内，这个位置也一定不是角，如果有两个在区域内，并且两个位置的垂直和水平方向上的距离都是1，即这两个相邻位置不在一条直线上，那么这个位置一定是一个角，最后如果只有一个相邻位置在区域内，说明这个位置存在两个角（在三个边上）。如果没有相邻位置在区域内，那么就有四个角，其实区域大小为1。~没有意识到角的数量等同于边的数量让我做了不少无用功。

计算区域角的数量并没有我最初所想的那么简单，仅仅通过判断一个位置的四个相邻位置是否在区域内并不行。自己尝试从各种角度解决，但是依旧没能取得正确的答案，没能静心分析，最后参考了 [Reddit/Polaric_Spiral](https://www.reddit.com/r/adventofcode/comments/1hcdnk0/comment/m1nkmol/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) 的计算角数量的思路。大致思路如下，在每一个位置，可能有的四个角中，每个角都可能有两种状态，内凹或者外凸的。
对于是外凸的角，那么在两个 90 度相邻位置的邻居必然不在区域内，可见示例对于北方和东方的角：
```
..
#.
```

对于内凹的角，那么在两个 90 度相邻位置的邻居必然在区域内，同时在这两个位置构成的对角线位置必然不在区域内，例如示例：
```
#.
##
```

刚开始我一直以一个位置四周的四个位置落在区域内的数量，作为位置是否在边上的判断条件，考虑形状为十字架的区域，十字架中心的位置实际上也是落在边上的，但是它的相邻四个位置都在区域内。我是直到计算角的数量才发现我在这个边界情况上的错误判断，对于我自己的方法，这个错误并不影响计算，因为既然是十字架形状，那么四个方向上除了中心位置肯定还有其他位置落在同一个边上，那么没有这个点也不影响边数量的计算。但是在计算角的数量的时候就要考虑到这一点，因为如果只计算边上的位置存在角的数量时，少掉一个位置肯定会影响结果。这个误判也不只出现在十字架的形状中，对于大部分内凹的角的位置，其实都会收到这个误判的影响，例如下例中 (1, 1) 处其实存在一个内凹的角，这个位置也落在边上，同时四个相邻的位置都在区域内。

```
AA.
AAA
AAA
```

今天的题目依旧不难，至少在时间、空间复杂度上不是偏难的题目，需要用的算法也很常见，但是在细节的处理上需要很好的分析。对于多边形边的数量等于角的数量这一知识点没能第一时间意识到，还有就是自己下了一些错误的决定，比如判断点是否在边上。这类题目其实就是考察边界情况，以及耐心。
