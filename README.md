# Advent of Code 2024

- https://adventofcode.com/
- https://github.com/livexia/advent-of-code-2024

## 移除所有的 input.txt

根据社区和作者的规定，其实参与者并不允许上传 input 到公共仓库，我之前一直没有意识到这个问题，所以为了可确定性所以一直上传输入，今天意识到这个问题，所以删除了所有的输入，也许还有少量残留（不太可能）。

使用的方法来自社区：
1. [Puzzle Inputs](https://old.reddit.com/r/adventofcode/wiki/faqs/copyright/inputs)
2. > git filter-repo --path-glob "2022/*/input" --invert-paths --force was the nice way to fix this for me. Edit the glob to match how you had inputs saved
    - 需要重新配置仓库远端地址，同时需要强制推送代码，以及 github 可能存在短暂的更新延时，以及可能的云端缓存，不是很确定，以及会丢失本地的 input 文件，也算是我的教训吧，下次记得要检查类似的问题。
    - [fragger](https://old.reddit.com/r/adventofcode/comments/18ehed6/re_not_sharing_inputs_psa_deleting_and_committing/kcroxma/)
3. [newren/git-filter-repo](https://github.com/newren/git-filter-repo)

## Day 1

太久没编程，还好大部分的记忆还在，有一点点手生，但是没什么问题。

## Day 2

第二天的题目并不困难，第一部分很简单，前后比较即可，第二部分虽然想有更好的方法，但是思路并不那么清晰，最后就暴力解决了，因为输入的问题，所以效率也不差。输入的数据每行的长度也不大，同时数据每行大都是有序的，而且也只考虑移除一个元素后数列的变化情况，所以实际上问题的求解空间就不大。如果输入数列趋于无序，同时需要计算删除最少元素以保证数列排序要求，那么求解空间就变得很大了，暴力实现也就不怎么现实了。在社区上简单浏览了一下也没有看见贴别好的方法，也许还要再等等吧，就这样了。

## Day 3

第三天的题目依旧不困难，但是在输入的处理上稍有麻烦，太久没编程都忘了还能用 regex 处理输入了，刚开始想要自己实现输入的匹配，但是没能下定决定，然后浪费了不少时间。虽然对 regex 并不是很熟练，但是基础还是有的，所以写个简单的表达式并没有问题，利用[网站](https://regex101.com/)简单的测试，再根据 [regex](https://docs.rs/regex/latest/regex/index.html) 的文档很容易的就实现了输入的解析和处理。对输入的计算其实很容易，再处理完输入之后很容易就可以得出结果。

## Day 4

今天的题目真的很简单，但是我却花了太多的时间，第一部分很快就有解决方法了，以为会出现的深度搜索也不需要，最后我的示例答案和正确答案差 1 ，我就知道有个边界错误了，但是光看是看不出来的，最后在纸上手动计算了一下，对比了差异，果然在边界上判断错误了。可能是小瞧了难度，所以写代码的时候有点过于花样多了，导致要从代码调试输出更加困难，而我又不想改，所以浪费了很多的时间。第一部分需要在水平、垂直和对角方向上搜索单词，注意无论是什么方向，单词都是在一行的，这极大的降低了问题难度。从一个位置出发，实际上需要匹配八个方向的所有可能，因为单词可以是翻转的，所以我并没有匹配八个方向，而是判断当前位置是和单词的第一个字符还是最后一个字符相同，如果和最后一个字符相同，那就翻转单词，这样在一个位置其实最多只需要寻找四个方向。第二个部分更加简单，只需要找到所有的字符 A 即可，判断以 A 为中心的，两个对角线的单词是否是 MAS 或 SAM 即可，只有都满足的情况才是正解，也就是说对于一个字符 A 其实只存在一个可能性。第一部分中无论是对于字符 X 还是 S ，其实都存在四种可能（我的解法）。吸取教训，不要求快，求快反而更慢了。

## Day 5

今天的题目依旧不难，但我还是太不熟练了，在很多的地方有的思路并不是最佳的，这些思路可能一年前对我来说是很自然的。题目给出的输入是一组排序规则，其中确定部分元素的前后关系，还有的一部分输入是可能有序的序列，第一部分要寻找其中已经按照排序规则有序的序列，取得中间元素的值。第二部分则要对未排序的序列进行排序，取得排序后序列中间元素的值。我的思路很直接明了，就是搜索，我先把输入的序列规则进行了处理，确定在一个元素之后的所有元素（对输入规则进行拓扑排序）。题目要求的是，需要排除序列中没有元素的排序规则，所以实际上对每一个序列都需要处理输入规则，也就是说对不同的序列，其实有不同的排序规则，因为如果不针对输入序列进行再次处理，会发现输入规则的拓扑排序存在环，那么所有的排序都是可行的，但其实存导致环的规则并不会同时出现在一个序列中，所以对于任一序列，规则是不存在环的（因为排除了）。按照我的方法，处理排序规则就已经有不少的复杂度了。然后在第二部分，需要对未排序的序列进行排序，我使用的排序算法也不是最好的，遍历比较前后元素，如果不符合排序规则就交换两个元素，然后回溯比较前一对是否有序（当前两个交换会影响前一对的比较结果）。

其实除了没有使用更好的排序算法，我的方法没啥问题，对需要的规则进行拓扑排序，但是在阅读社区的解法和讨论之后，我意识到对于序列中任何两个相邻的元素，必然存在规则确定二者的大小关系，即如果存在 `a|b` 和 `b|c` 两条规则，那么规则 `a|c` 必然存在，所以对于某一输入序列而言，实际上一定存在对应的规则，也就是说对于某一输入而言，其实完全不需要进行拓扑排序，即可能发生的比较都已经在需要的规则中确定好了，只需要取用即可。在对自己爹输入测试之后果然如此，理所当然的这个方法比我自己的方法要快很多。

参考：[\[2024 Day 5\]Rules are not a DAG ](https://www.reddit.com/r/adventofcode/comments/1h73c98/2024_day_5_rules_are_not_a_dag/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)

## Day 6

今天的题继续不难，提交的成绩比前几天好太多了，但是在完成之后依旧卡壳。这类型的题目已经是 AOC 的传统艺能了，所以在输入处理和抽象建立上并没有问题，第一部分就是按照提议要求模拟行走就行，很简单。第二部分很明显复杂了一些，但是本质上还是做 N 次第一部分的内容，所以实际上理解也不困难，并没有很直接的算法能够加快这个过程。很自然的，我尝试用暴力法，逐一替换给出地图中的路径为障碍，然后一一测试是否存在环路，环路判断只需要用 `HashSet` 保存守卫的位置和前进方向，然后当再次遇到状态一模一样的守卫时，就发现了环。理所当然的这个方法的效率并不好。因为每次守卫巡逻，最多只允许替换一次路径为障碍，那么实际上对那些守卫本就不会走到的路径就没有必要替换为障碍进行测试，所以可以先把不替换时守卫巡逻的所以位置进行记录，然后只需要对这些位置进行替换，再测试环即可，这可以大量降低运行时间。那么能不能再进一步加快运行效率呢？我就是卡在这个问题上了。在前面两种方法中，每次替换并检测环的时候，守卫都是从起始位置行走的，那存在大量的重叠运算，假如被替换的位置处于守卫巡逻路径的最后部分并且相邻，那么理论上可以对部分的运算进行复用。所以我就有了这样的思路，守卫在巡逻路径上某一个位置的时候，他存在两种选择，第一就是按照未替换的巡逻路径前进一个位置，或者把路径下一个位置替换为障碍，即守卫进行转向。对于巡逻路径上的每一个位置都存在两种选择，所以对于长度为 N 的巡逻路径未替换的路径需要计算一次，除去初始位置其余位置都需要计算一次。如果路径不存在交叉，也就是最理想的情况，那么总共需要移动的次数就是 N + (N - 1) + (N + 2) + ... + 1，这个结论不完全正确，因为当一个位置被替换后，其实路径的长度也会变化。刚开始我一直没有考虑可能的路径交叉情况，正是在这个情况的判断上，我无法取得正确的结果。

考虑位置 A 处于巡逻路径的某个位置，而且路径会多次经过 A ，如果在首次前进到 A 处，测试将 A 替换为路障是否存在环路。如果不存在那么按照原本的巡逻路径继续前进再次到达 A 位置时是否需再次测试？这个情况下是不需要测试的，因为如果进行替换，那么首先到达当前状态的前提就不存在了，替换并不是在前进到某个时刻随意选择替换的，而是在守卫开始走的时候就进行替换的。回到如果 A 存在回路的情况，那么按照原本路径再次到达 A 时同样的也不需要进行测试，因为替换 A 已经验证是存在回路的。

按照这个思路实现的代码结果依旧不对，相比于正解更少的位置在替换后能使得守卫巡逻路径为环路，也就是存在部分环路没有被成功的检测，也许是环路检测部分的代码有问题。考虑边界情况，起始和路径上的其他位置没差别，因为替换的是下一个位置的，路径最后一个位置时，下一个位置不在输入范围内，所以也就不存在两种情况。在写下这段思考之后，仔细研究发现在判断交叉位置的部分是存在错误的，调整之后这个方法毫无问题。

代码在 release 编译下从最初的 8s 到中间的 2s 到现在的 500ms ，代码效率提升明显，但是仍旧不快，因为大量使用了 `HashSet` ，在火焰图中也可以发现 Hash 的相关操作占据了大部分的运行时，这个部分依旧可以优化。需要哈希的主要数据类型是两个 `usize` 构成的 `tuple `和一个 `enum` ，理论上的哈希操作并不困难。观察火焰图可以发现存在大量的 `rehash` ，就是说存在大量哈希重新计算的情况，大概率是 `HashSet` 的容量增长导致的，所以在新建 `HashSet` 的时候可以提前分配一个较大的空间，这样操作之后运行时间减少一半，同样的 `rehash` 在火焰图中也没有多少。当然这样的性能提升依旧有限，因为还是存在大量的 `insert` 操作，也许可以换第三方的哈希库，但是也许可以用完全不同的方法。

在某一个位置，守卫最多存在四种前进方向，也就是说某一个位置最多存在四种状态，那么就可以用一个三维数组存储这些，直接利用数组替换哈希，测试发现数组比哈希更慢，这也可以理解，因为数组需要更大的空间，哈希其实还是只用了较少的空间。因为输入的大小为 130x130 理论上可以用大小为 `[[u64; 43]; 130]` 的 array 对应输入二维矩阵每个位置的状态，同样只需要四个这样的 array 对应守卫在每一个位置可能有的四种状态。通过位运算，可以将每个坐标对应到这个 array 中 u64 的一个 bit 上，这也是 AOC 中经常出现的优化。我在今天的题目上已经花了很多的时间，就随它去。

参考了 Reddit 的[评论](https://www.reddit.com/r/adventofcode/comments/1h7vpqi/comment/m0pcrrh/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) 和[帖子](https://www.reddit.com/r/adventofcode/comments/1h8g6za/2024_day_6_part_2_various_optimization_tricks/) 我意识到在环检测的时候，只需要保存在守卫发生转向时的状态即可，如果成环那么守卫一定会走过每个角落多次，这可以减少需要保存和检查的状态值。这个优化是显著的，在 debug 编译下，运行时间降低到了 300ms ，release 下则降低到了 70ms。

## Day 7

也许是最简单的一天，这让我担心明后天的题目了，没有什么特别的花样，老老实实的暴力递归解决，清晰明了，看社区貌似也没更好的方法。有一个 rust 的语法糖（？），可以用 `checked_ilog10` 确定一个数的十进制长度。

## Day 8

题目在描述上有些含糊不清，和前后矛盾，理论上一条直线上的三个点，分别为 A，B 和 C，其中 A 和 C 的距离刚好是 B 和 C 的距离的一半或者一倍，A 和 B 位置确定，那么满足这个条件的点 C 应该有四种可能，题目却说只有两种可能。对这两种可能题目很明确的说是在两点的两侧，也就是说不可能落在两点之间。从这个条件出发，计算 A 和 B 两个方向上的距离差，然后第一部分只要点 A 减去距离差以及点 B 加上距离差即可，第二部分则是不断进行这个延伸，直到超出边界。题目很简单，说实在的也没什么优化的空间。

## Day 9

一看见题目就知道应该采取怎么样的思路，但是太久没写类似的题目了，所以只有大概的思路，很明显是需要用区间解决的。但是我在决定该如何表达区间上犹豫不决花了太多的时间，所以我决定用暴力法试试看，在计算了需要的数组大小并不是特别大之后，用模拟的方法很容易的就解决了今天的问题，当然运行时间并不好，所以我还是需要用区间的思路解决。输入包含了两类区间，分别是文件和空闲，第一部分需要将文件拆分，填满空闲区间，文件从尾部开始拆分，而空闲空间从头部开始填满。第二部分则是不将文件拆分，需要将整个文件移动到可以容纳的空闲区间。

考虑第二部分，当一个文件移动到一个空闲空间时，首先文件占用的位置设为空，因为是从尾部的文件开始移动，而且一个文件最多只能尝试移动一次，所以位置上在这个文件之后的文件都已经被尝试过了，同时因为文件都是向前移动，所以这个文件移动后留空的部分只需要置空，而无需将其是做可能有文件会移动的空闲空间（空闲但不允许被写入）。然后考虑被占用的空闲空间，首先存在两种情况，一是大小刚刚好，那么这个空闲空间需要被删除，后续其他文件的移动无需考虑，而是大小大于文件的大小，那么就要调整空闲空间的区间值。

考虑第一部分，当一个文件移动后留下的空闲空间依旧是无法作为移动的空闲空间使用。当文件小于空闲空间时，实际上就是第二部分，而当文件大于空闲空间时，则需要拆分文件的区间，优先处理一部分文件，同样的处理过的文件不在移动。实际上对于第一部分，其实用暴力法来的更加方便，因为并不存在文件间的区分，而且从头部开始的空闲空间总是会被填满的，以及尾部的占用空间总是会移动，所以只需要用双指针分别表示最初的空闲空间以及最后的占用空间即可，然后不断的替换两个指针处的空间即可，时间复杂度是 O(N) ，虽然利用区间进行计算，时间复杂度应该也是 O(N) ，但是涉及到文件间的区分，逻辑上就更加复杂了。实际上的运行时也有差距，在第一部分就使用区间涉及到更多的查找操作，或者是移除无用的空闲空间所耗费的开销。

应该能进一步的优化，第二部分中查找符合大小的空闲区间我是直接线性搜索的，应该存在更好的搜索算法，也许可以维护一棵树？Reddit 社区有提到区间树，应该可以更快的找到满足要求的区间，只不过题目比一般的区间树其实存在更多的要求，比如移动后的空闲区间不能再使用（不插入区间树），以及区间要移动到起点较小的区间（需要修改区间树的查询？）。

参考：[Interval tree](https://en.wikipedia.org/wiki/Interval_tree)

## Day 10

今天的题目很简单，输入处理也很简单，输入也很小，搜索路径。两个部分之间也没什么差别，第一部分需要计算从一个位置能达到多少个目标，第二部分则需要计算从一个位置能有多少路径达到目标。第一部分误读了几次题意，其实就出现了第二部分的解。第一部分可以保存搜索过的路径，减少搜索空间，第二部分则可以保存搜索过的每个位置到目标的路径数，动态规划，减少搜索空间。但是因为输入太小了，所以根本无所谓，递归的深度优先搜素或者迭代的广度优先搜索都可以实现。

## Day 11

给定的输入其实很小，处理也相当容易，看完题目其实就知道是存在某种循环、规律，第一部分往往都可以直接模拟解决，经过一次变化，石头数最多翻倍，第一次的变化次数很少，所以在时间、空间复杂度上，简单的模拟是完全可以实现的。

第二部分循环的次数增加的，对于模拟而言次数增加一次，模拟操作是翻倍的，所以时间、空间复杂度是指数增长的，需要寻找某种模式或者更好的算法。对于类似的变化题目，很大程度上都是要寻找某种固定的模式，减少实际需要模拟的次数。简单的检查每次变化后石头的数字， 发现第二部分很明显会进入一个循环的状态，所有石头可能的数字并不增加，数字相同的石头不断增加。那么就可以对石头的转换进行缓存，保存每次缓存的结果，当再次遇到一样数字的石头时直接从缓存中取得即可，不需要重复的模拟。同时在计算过程中并不保存所有石头，而是记录每个石头出现的次数，那么就可以很轻易的计算（乘法）出所有这些相同数字的石头经过变换后会变为哪些石头。也许可以进一步分析每一次变化后，相同数字石头数量的变化，确定这个规律后，甚至可以直接取消重复模拟计算。当然这个规律并不容易取得，而且存在石头间的变化，所以单对一个数字进行分析是很难推出规律的，实际的测试也说明这一点。

再阅读了部分社区的解法之后，也有一个类似但不同的思路，类似动态规划，令 f(x, n) 为数字为 x 的石头经过 n 次变化后可能的石头数，那么根据变化规则就可以判断 f(x, n) 为 f(1, n - 1) 或者 f(left(x), n - 1) + f(right(x), n - 1) 或者 f(x * 2024, n) ，同时如果 n 为 0 f(x, 0) = 1，这就是石头变化数量的转换方程。转换过程中只需要缓存即可。某种程度上这两种角度是同一个方法的不同表现，第一种方法减少了每次需要判断的石头数，第二种方法则是减少了转换的次数。  

## Day 12

应该是连通性的问题，连接区域的面积比较容易计算，可以计算区域中和相邻区域接触的数量即可，用深度搜索实现即可，当前位置的四个方向上存在不是本区域的植物即是边界的一部分，第一部分还是很轻松的，只是要在搜索过程中排除已经搜索过的位置即可。

第二部分需要计算连接面积的边的数量，处在边上的元素最多只和两个相同元素相连，当存在转弯时，搜索到新的边。这个思路没问题，但是实际的实现并不清晰，浪费了很多时间，最后我决定用笨办法，遍历区域中所有的点，确定四个相邻的点有多少是在区域内的，如果四个都在区域内说明这个点不在边上。如果有三个都在区域内，说明这个点在边上，只有一个方向与其他区域相邻，然后我记录这个边的直线以及这个点是在这个边的哪个方向（边的哪个方向是不在区域内的），将边和边的方向作为哈希表的键，以及点作为哈希表的值进行保存。同样的如果只有两个相邻的点在区域内，那么这个点就存在两个边上，同样的写入哈希表。一样的保存只有一个相邻点在区域内时三边和对应方向到哈希表。

参考 Reedit 的解法之后，其实我的第一个思路是没问题的，只不过我没意识到只要确定区域每有一个角就有一个边。~而实际上在我的第二个方法里，我已经计算了角的数量，如果一个位置的四个相邻位置中有四个都在区域内，这个位置一定不是角，如果有三个都在区域内，这个位置也一定不是角，如果有两个在区域内，并且两个位置的垂直和水平方向上的距离都是1，即这两个相邻位置不在一条直线上，那么这个位置一定是一个角，最后如果只有一个相邻位置在区域内，说明这个位置存在两个角（在三个边上）。如果没有相邻位置在区域内，那么就有四个角，其实区域大小为1。~没有意识到角的数量等同于边的数量让我做了不少无用功。

计算区域角的数量并没有我最初所想的那么简单，仅仅通过判断一个位置的四个相邻位置是否在区域内并不行。自己尝试从各种角度解决，但是依旧没能取得正确的答案，没能静心分析，最后参考了 [Reddit/Polaric_Spiral](https://www.reddit.com/r/adventofcode/comments/1hcdnk0/comment/m1nkmol/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) 的计算角数量的思路。大致思路如下，在每一个位置，可能有的四个角中，每个角都可能有两种状态，内凹或者外凸的。
对于是外凸的角，那么在两个 90 度相邻位置的邻居必然不在区域内，可见示例对于北方和东方的角：
```
..
#.
```

对于内凹的角，那么在两个 90 度相邻位置的邻居必然在区域内，同时在这两个位置构成的对角线位置必然不在区域内，例如示例：
```
#.
##
```

刚开始我一直以一个位置四周的四个位置落在区域内的数量，作为位置是否在边上的判断条件，考虑形状为十字架的区域，十字架中心的位置实际上也是落在边上的，但是它的相邻四个位置都在区域内。我是直到计算角的数量才发现我在这个边界情况上的错误判断，对于我自己的方法，这个错误并不影响计算，因为既然是十字架形状，那么四个方向上除了中心位置肯定还有其他位置落在同一个边上，那么没有这个点也不影响边数量的计算。但是在计算角的数量的时候就要考虑到这一点，因为如果只计算边上的位置存在角的数量时，少掉一个位置肯定会影响结果。这个误判也不只出现在十字架的形状中，对于大部分内凹的角的位置，其实都会收到这个误判的影响，例如下例中 (1, 1) 处其实存在一个内凹的角，这个位置也落在边上，同时四个相邻的位置都在区域内。

```
AA.
AAA
AAA
```

今天的题目依旧不难，至少在时间、空间复杂度上不是偏难的题目，需要用的算法也很常见，但是在细节的处理上需要很好的分析。对于多边形边的数量等于角的数量这一知识点没能第一时间意识到，还有就是自己下了一些错误的决定，比如判断点是否在边上。这类题目其实就是考察边界情况，以及耐心。

## Day 13

今天的题目和让人措手不及，总感觉应该是需要用到算法了吧，题目的描述又好像存在某种最优解，某种最优的抓取方式使得最后的耗费最少。带着这种偏见，我就用动态规划解决第一部分，令 m(p) 为到达奖品 p 处的最少耗费，那么就有如下转移方程 m(p) = min{3 + m(p - 1), 1 + m(p - b)}，其中 a 和 b 为按钮 a 和 b 移动的距离，同时还有边界条件 m((0, 0)) = 0 。根据这个就可以实现递归的方式从上往下依次计算，期间保存 m(p) 可以减少中间的计算过程，当然运行时间并并不好，因为还是有很多无用功。

第二部分把求解空间瞬间放大，再用动态规划就不现实了，花了我好一会才意识到这个题目根本不需要动态规划，有一个很重要的提示是题目不断地说起某些机器永远无法到达奖品位置，一般来说对于动态规划的问题，往往是存在多解，比如最短路径，往往是需要从中选择最优，有两个关键词很重要，就是多解和最优。因为最优把我引导到了动态规划，但是我却没有思考一下究竟是不是存在多解，是不是真的有所谓最优的情况。

动态规划里很常见的题目就是青蛙跳的题目了，一次跳一步还是两步计算最少的跳跃次数，在这个常见的问题里，求解空间是一维的，也就是说其实是一个二元一次方程，这样的话是存在多个解的，动态规划也就适用了。

而这个题目，抓取爪是在两个方向上移动，同时每个按钮也是控制抓取爪在两个方向上移动一定距离，同时奖品位于二维空间的特定位置，而且只有当抓取爪恰好处于所需要的位置时才能抓取成功，所以需要同时在两个方向上到达奖品位置，那么就构成了两个个二元一次方程组，其中参数和元都要是整数。只要计算这个方程组的解即可，而对于两个二元一次方程，是存在唯一解的，同时题目涉及到的解又只可能是整数，所以只要解方程就好了，用消参法可以很容易的计算唯一解，只要判断是不是整数即可。对于这个问题，其实根本不存在什么最优解，因为就一个解，对于算法的适用场景，还是要更仔细的分析才行，不要轻易被部分关键词所误导。

## Day 14

今天的题目依旧有些出其不意，第一部分简单的模拟即可，当然不需要构建地图进行一步一步的模拟，直接更新机器人的坐标即可，不过要注意当机器人移动到边界时会瞬移，也就是可能会溢出边界，需要对坐标进行求余操作，rust 中 `%` 的运算符会保留符号，取得的结果并不靠向 0 ，所以需要用 `rem_euclid` 计算非负的余数才行。

第二题其实很让人困惑，即没给出大概范围，又没给出需要搜索的形状，只是很模糊的表示大部分机器人可能会构成一个圣诞树的图片，那就只能自己找规律了。我先在每一次移动之后都打印出机器人的现有位置，自然的这样有大量的干扰输出，保存输出的文件不一会就超过 1G ，然后观察输出可以发现其中部分输出机器人会大部分的位于几行或者几列。最初我想是不是应该统计在集中出现几行和几列的频率，然后当同时出现在几列和几行的时候，就是结果，但是对我来说这个思路有点麻烦，因为既要检测形状，又要检测环。然后我就想到，如果大部分的机器人都构成一个图片，那这些机器人之间的距离应该是较小的，于是在每一次移动之后我都计算每对机器人间的距离，如果距离小于之前记录的最小距离，说明这个时候**可能**是构成了圣诞树。用这个方法很容易的过滤了大量的输出，同时也可以很容易的从中发现的确有正解。取得正解之后，为了避免程序不断循环，我增加了最小距离更新的时间间隔上限，如果超过这个上限最小距离还没更新，就退出程序，当然这是事后之明，这个方法其实也是有些运气的，如果作者夹杂了其他的不是圣诞树的图片，那么就可能会有错误的解，但是这类题目本身就有点像脑筋急转弯，严谨并不是最重要的部分，这类题目的有趣也就在此。

Reddit 上除了我这样的方法还有其他一些方法，都各有创意，也各有运气。就我个人而言这类题目最有趣，略微脱离某种严谨的编程，我还记得几年前有个题目最好的方法是折纸盒，这类问题阅读大家的方法也很有启发。

1. [将输出存为 PNG 格式，然后检查文件大小较小的输出，因为有规律的图片压缩更加优秀](https://www.reddit.com/r/adventofcode/comments/1hdvhvu/comment/m1z79gn)
2. [计算连接机器人的数量，当数量超过一个人为给定的阈值之后，可能就是正解](https://www.reddit.com/r/adventofcode/comments/1hdvhvu/comment/m1z7j2t)
3. [检查位置重叠机器人的数量，当没有机器人重叠的时候，即为正解](https://www.reddit.com/r/adventofcode/comments/1hdvhvu/comment/m1z9by8)
4. [我的第一思路，计算大部分集中在行和列的频率，计算相交也是可行的](https://www.reddit.com/r/adventofcode/comments/1hdwqgy/2024_day_14_part_2_the_rsi_solution)
5. 也许可以检查四个象限接触部分机器人的数量，因为最后结果圣诞树大致处于图片中间的位置。

参考：[rem_euclid](https://doc.rust-lang.org/std/primitive.isize.html#method.rem_euclid)

## Day 15

今天的题目有点麻烦，第一部分其实还好，利用递归检查移动方向上下一个位置是否可以通行，存在如下三种可能：

1. 当下个位置空闲时可直接交换前后两个位置。
2. 当下个位置为墙壁时说明机器人无法移动。
3. 当下个位置为箱子，而且这个箱子通过递归判断最终是可移动的，那就交换当前位置和下一个位置。

在这个递归中，总是在遇到空闲位置时开始交换位置，也就是说空闲位置不断的向最初位置进行交换，同时有且仅有递归搜索最后存在空闲位置才进行交换。

第二部分复杂了一点，地图被拉伸了，一个箱子本来只占据一个位置，现在箱子占据了左右两个位置（高度不变，宽度翻倍），但是机器人的大小不变。那么当机器人遇到箱子后，就存在多种情况。如果机器人的运动方向是向左或向右，那么机器人推动箱子的逻辑和之前其实是一致的，机器人推动一个箱子，然后箱子可能继续推动同一个方向上的箱子，依次类推直到遇到一个空闲位置。复杂的情况就是当机器人的运动方向为向上或向下，当机器人推动箱子时，因为箱子的宽度增加变成 2 了，那么一个箱子在运动方向上可能就会推着两个箱子，依次类推机器人最终推动的箱子可能是像一棵树一样，只有每一层的多个箱子都能被推动机器人才能移动。这个箱子树之间是存在依赖关系的，考虑机器人推动一个箱子 a ，而箱子 a 推动了两个箱子 b 和 c ，假设箱子 b 能被推动，但在确认箱子 c 能否被推动之前，是不应该推动箱子 b 的，反之亦然。也就是说对于第二部分简单的搜索回溯并不行，因为搜索的分支会决定是否需要回溯。

基于这个认识，我写出了解决方案，但是我的方法很丑陋，大致是进行了 2 次搜索，第一次确定机器人是否能够移动，如果机器人能够移动，第二次则移动箱子。这个思路虽然不是最优雅的，但却是没错的，结果我浪费了很多的时间在这个方法上，因为确定思路没错，所以不断的尝试取得正确答案，最后发现是在分支的判断上存在问题，导致部分情况没考虑到，而这些情况只存在复杂的情况中，对于给出的示例根本就不会遇到这些情况。

更好的思路是只进行一次搜索，在判断机器人能否移动的搜索中记录所有可能被推动的箱子，如果机器人能移动，那么最后只要循环推动这些记录的箱子即可。即便得到了所有可能需要移动的箱子，依然有一个问题没有解决，那就是推箱子的顺序问题，箱子移动留下的空间要么置空，要么被其他需要移动的箱子占用，那么就存在一个移动顺序，如果不按照移动的先后顺序修改地图，就有可能导致置空被写入，或者本需要的空间被置空。但是可以首先将所有需要移动的箱子占用空间置为空闲，再一次性的将所有箱子移动后需要的空间写入箱子，这样可以直接规避写入顺序的问题。对一个箱子而言，移动前的位置须要被置空，新的位置的箱子需要移动，所以不妨先都置空，再一次性重新写入箱子。移动并不导致箱子增加或减少，这样也避免由于移动顺序导致的箱子重叠问题。

上面这个思路没问题，但是应该还存在优化空间，我其实将机器人推动箱子和箱子推动箱子分开看了，但是理论上我可以将这二者归纳起来，箱子推箱子几乎就是两个机器人推箱子，这样应该能实现一定程度的优化。参考：[SuperSmurfen](https://www.reddit.com/r/adventofcode/comments/1hele8m/comment/m250a7q)

自己实现了这个方法，这个方法有一个弊端，如果将所有移动都视为机器人移动，那么在判断箱子能否移动的时候就需要根据情况检查两个可能位置的情况。假如一个箱子的正上方刚好是另一个箱子，那么在判断当前箱子的两个部分时就会分别判断对应上方整个箱子空间是否适适用，会涉及较多的重复判断，所以需要引入哈希表记录当前位置是否正在判断，而这会增加运行耗时。

## Day 16

今天终于遇到了我不会的题目了，题目其实很简单，就是最短路径，但是我并不熟悉相关的算法，尝试用 DFS 解决的时候，发现自己在很多细节上并不是最短路径的解决方法，我不断的在类似的题目上犯这个错误。然后用 BFS 解决的时候才理清了思路，但是无论是 BFS 还是 DFS 其实都会耗费大量的时间，因为在我的 BFS 和 DFS 方法中并没有实现什么缓存，也就是说我在搜索过程中不断的进行重复计算。

~可以从题目中取得转移方程，令 m(c, f) 为坐标 c 和方向 f 到目标位置的最小分数，那么就有 m(c, f) = min{m(c-1, f) + 1, m(c, clockwise(f) + 1000, counterclockwise(f) + 1000} ，转移方程很明确，如果采用动态规划就能减少计算量，自顶向下要从初始点开始搜索，自底向上则要从目标位置开始，，无论是自顶向下还是自底向上其实都要穷尽可能性，否则将会出现我一直反的错误，即缺失了部分路径。~

最后自己绞尽脑汁依旧没想到该怎么实现，当然我是知道 Dijkstra 的最短路径算法是可以的，可是我并没有掌握这个算法，于是最后选择查看了相关的 wiki 页面，阅读了伪代码，然后自己实现了，在细节上因为对算法的理解不够，所以过程也不是一帆风顺，好在最后完成了第一部分。

第二部分实际上则是要取得所有的最短路径，应该也可以用 Dijkstra 算法解决。通过在过程中每当从起始节点到当前位置节点减少或**不变**时，记录当前位置的前置节点，并及时根据新的最短距离更新当前节点的前置节点集合，用 HashMap 进行表示，其中键为当前节点，而值为一直的最短距离和这个最短距离时已经发现的前置节点集合，当距离不变时将新的前置节点加入集合，当距离变小时，清空集合，同时将前置节点加入集合。

今天的题目相比于一般的深度搜索或广度搜素，复杂的地方在于移动是存在方向限制的，而且方向存在着权重，所以一个位置上以某一种方向运动的麋鹿存在三个可能的走向，一个位置的麋鹿最多可能有四种方向，所以一个位置有个状态，四个节点。

阅读了部分社区的解之后，DFS 和 BFS 其实也是可行的，只不过需要将平时法访问表改变一下，一般来说访问表一般是检查/搜索过的集合，当再次遇到相同状态就跳过，但在最短路径的算法中这个方法不可行，因为可能会跳过较优解，所以需要将访问表设为该状态目前的最短距离，如果再次遇到时距离大于访问表中的最短距离，就可以跳过搜索。

即使用了 Dijkstra 我发现我的方法依旧不算快，然后通过火焰图发现我犯了一个很严重的错误，极其不应该的错误，Dijkstra 算法最后会取得其实状态到所有状态的最短距离，因为题目最后需要求的状态可能有好几个（不同方向进入目标位置），我的错误就在如何从所有最短距离中找到我需要的状态。我用目标位置的坐标去匹配所有节点的坐标，然后筛选出需要的最短距离。正确的方法，应该是直接构造目标位置可能的四种状态，直接用哈希表的查找即可。相当于 O(1) 能完成的操作，我用了 O(N) 的操作完成。
