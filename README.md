# Advent of Code 2024

- https://adventofcode.com/
- https://github.com/livexia/advent-of-code-2024

## 移除所有的 input.txt

根据社区和作者的规定，其实参与者并不允许上传 input 到公共仓库，我之前一直没有意识到这个问题，所以为了可确定性所以一直上传输入，今天意识到这个问题，所以删除了所有的输入，也许还有少量残留（不太可能）。

使用的方法来自社区：
1. [Puzzle Inputs](https://old.reddit.com/r/adventofcode/wiki/faqs/copyright/inputs)
2. > git filter-repo --path-glob "2022/*/input" --invert-paths --force was the nice way to fix this for me. Edit the glob to match how you had inputs saved
    - 需要重新配置仓库远端地址，同时需要强制推送代码，以及 github 可能存在短暂的更新延时，以及可能的云端缓存，不是很确定，以及会丢失本地的 input 文件，也算是我的教训吧，下次记得要检查类似的问题。
    - [fragger](https://old.reddit.com/r/adventofcode/comments/18ehed6/re_not_sharing_inputs_psa_deleting_and_committing/kcroxma/)
3. [newren/git-filter-repo](https://github.com/newren/git-filter-repo)

## Day 1

太久没编程，还好大部分的记忆还在，有一点点手生，但是没什么问题。

## Day 2

第二天的题目并不困难，第一部分很简单，前后比较即可，第二部分虽然想有更好的方法，但是思路并不那么清晰，最后就暴力解决了，因为输入的问题，所以效率也不差。输入的数据每行的长度也不大，同时数据每行大都是有序的，而且也只考虑移除一个元素后数列的变化情况，所以实际上问题的求解空间就不大。如果输入数列趋于无序，同时需要计算删除最少元素以保证数列排序要求，那么求解空间就变得很大了，暴力实现也就不怎么现实了。在社区上简单浏览了一下也没有看见贴别好的方法，也许还要再等等吧，就这样了。

## Day 3

第三天的题目依旧不困难，但是在输入的处理上稍有麻烦，太久没编程都忘了还能用 regex 处理输入了，刚开始想要自己实现输入的匹配，但是没能下定决定，然后浪费了不少时间。虽然对 regex 并不是很熟练，但是基础还是有的，所以写个简单的表达式并没有问题，利用[网站](https://regex101.com/)简单的测试，再根据 [regex](https://docs.rs/regex/latest/regex/index.html) 的文档很容易的就实现了输入的解析和处理。对输入的计算其实很容易，再处理完输入之后很容易就可以得出结果。

## Day 4

今天的题目真的很简单，但是我却花了太多的时间，第一部分很快就有解决方法了，以为会出现的深度搜索也不需要，最后我的示例答案和正确答案差 1 ，我就知道有个边界错误了，但是光看是看不出来的，最后在纸上手动计算了一下，对比了差异，果然在边界上判断错误了。可能是小瞧了难度，所以写代码的时候有点过于花样多了，导致要从代码调试输出更加困难，而我又不想改，所以浪费了很多的时间。第一部分需要在水平、垂直和对角方向上搜索单词，注意无论是什么方向，单词都是在一行的，这极大的降低了问题难度。从一个位置出发，实际上需要匹配八个方向的所有可能，因为单词可以是翻转的，所以我并没有匹配八个方向，而是判断当前位置是和单词的第一个字符还是最后一个字符相同，如果和最后一个字符相同，那就翻转单词，这样在一个位置其实最多只需要寻找四个方向。第二个部分更加简单，只需要找到所有的字符 A 即可，判断以 A 为中心的，两个对角线的单词是否是 MAS 或 SAM 即可，只有都满足的情况才是正解，也就是说对于一个字符 A 其实只存在一个可能性。第一部分中无论是对于字符 X 还是 S ，其实都存在四种可能（我的解法）。吸取教训，不要求快，求快反而更慢了。

## Day 5

今天的题目依旧不难，但我还是太不熟练了，在很多的地方有的思路并不是最佳的，这些思路可能一年前对我来说是很自然的。题目给出的输入是一组排序规则，其中确定部分元素的前后关系，还有的一部分输入是可能有序的序列，第一部分要寻找其中已经按照排序规则有序的序列，取得中间元素的值。第二部分则要对未排序的序列进行排序，取得排序后序列中间元素的值。我的思路很直接明了，就是搜索，我先把输入的序列规则进行了处理，确定在一个元素之后的所有元素（对输入规则进行拓扑排序）。题目要求的是，需要排除序列中没有元素的排序规则，所以实际上对每一个序列都需要处理输入规则，也就是说对不同的序列，其实有不同的排序规则，因为如果不针对输入序列进行再次处理，会发现输入规则的拓扑排序存在环，那么所有的排序都是可行的，但其实存导致环的规则并不会同时出现在一个序列中，所以对于任一序列，规则是不存在环的（因为排除了）。按照我的方法，处理排序规则就已经有不少的复杂度了。然后在第二部分，需要对未排序的序列进行排序，我使用的排序算法也不是最好的，遍历比较前后元素，如果不符合排序规则就交换两个元素，然后回溯比较前一对是否有序（当前两个交换会影响前一对的比较结果）。

其实除了没有使用更好的排序算法，我的方法没啥问题，对需要的规则进行拓扑排序，但是在阅读社区的解法和讨论之后，我意识到对于序列中任何两个相邻的元素，必然存在规则确定二者的大小关系，即如果存在 `a|b` 和 `b|c` 两条规则，那么规则 `a|c` 必然存在，所以对于某一输入序列而言，实际上一定存在对应的规则，也就是说对于某一输入而言，其实完全不需要进行拓扑排序，即可能发生的比较都已经在需要的规则中确定好了，只需要取用即可。在对自己爹输入测试之后果然如此，理所当然的这个方法比我自己的方法要快很多。

参考：[\[2024 Day 5\]Rules are not a DAG ](https://www.reddit.com/r/adventofcode/comments/1h73c98/2024_day_5_rules_are_not_a_dag/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)
